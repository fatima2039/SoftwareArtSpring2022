
For this assignment, I decided to play around with the physics of the movement of objects on screen. To break down the sketch, there are particles represented by icospheres that are generated every third frame. Their initial location is randomized on screen. Their mass, which controls the speed of the particle and its force of attraction to other particles, is also generated randomly in the start. The color of each particle is also set at random from the available theme colors that are set to one of the previous sketches. Using these colors on the black background makes for a visually pleasing app. Additionally, each particle is given a particular lifespan and it decreases by 1 at each iteration of update(). This value is used as the opacity of the color of the particle and reduction in opacity demonstrates the slow fading away of the particle. At every iteration of draw(), the location of the particle is updated based on the position of other particles, especially the ones that are being newly generated. The distance between two particles and their relative masses controls their velocity, acceleration and thereby the updated location. 

<img width="49%" alt="Screenshot 2022-04-24 at 7 33 16 PM" src="https://user-images.githubusercontent.com/72029531/164986490-e8173bbf-7786-401b-ac8d-407ebfe08b65.png"> <img width="49%" alt="Screenshot 2022-04-24 at 8 32 25 PM" src="https://user-images.githubusercontent.com/72029531/164986576-2a56d103-cb49-47d1-8e94-dd3226761196.png">

The concept of the particle resonates with an idea, an opinion or a voice. The formation of clusters is the agreement of ideas or similarity amongst them. The movement of a new particle towards the cluster is a demonstration of how a new idea (so different in many aspects) has a tendency to be like the majority. In the cluster, we see the regeneration of the majority. Many new particles join as many old fade away. This cycle keeps the balance and we no matter what always have a majority. Additionally, the majority also tends to attract another majority. As you would see in the app, as multiple new particles are being generated at one place, the existing cluster tends to move towards the new one. Both sort of attract each other and rest at a mean position. After the forced generation of particles from one place is stopped, the new particles keep coming from random locations from all over the frame and the cluster tends to move back towards the center of the screen - the mean position of the particles. 
Check out the app in action here: https://youtu.be/z1R8HzPOnfc 

A main issue that I encountered in this app was when I tried to add the z dimension in the position of the particles. It would be so interesting to look at in the start, but a couple of seconds later, the whole app would crash. My system would freeze and had to start over with the development process. After many failed attempts to figure out the cause, probably the insufficient fast processing of the system, I decided to stop this implementation. Similar thing happened with the inclusion of ffmpeg recording in the sketch. Installation of homebrew and ffmpeg took so long but did complete. I followed the steps in the guide for addons and the code to be incorporated in. However, the app would be terminated each time on key press giving the following error. 
./addons/ofxFFmpegRecorder/libs/ffmpeg/lib/osx/ffmpeg: No such file or directory
Message from debugger: Terminated due to signal 13

I tried following multiple discussions in the openframeworks forums but nothing worked. So, I ended up recording my screen. 

This sketch has been completely different from what I envisioned. While I worked on my previous app to add motion, I thought of changing shapes and different movement parameters. One change led to another and I ended up with something very unexpected but much stronger in concept and workflow. Despite the issues I ran into during the development, the final outcome is still worth it. Playing around with different parameters gave so many different perspectives to the views and all were amazing. In the end, it was so hard to stick to one value. If time permits, it will be interesting to allow users to control the parameters and see the changes in real time. Maybe a thing to pick up on in the next assignment.
